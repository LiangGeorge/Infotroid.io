<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>Video Capture Example</title>
<!-- <link href="js_example_style.css" rel="stylesheet" type="text/css" /> -->
<link rel="stylesheet" href="style.css">
</head>
<body>
<h2>Video Capture Example</h2>
<div>
<div class="control"><button id="startAndStop">Start</button></div>
<textarea class="code" style="display: none;" rows="0" cols="0" id="codeEditor" spellcheck="false">
</textarea>
</div>
<p class="err" id="errorMessage"></p>
<div>
    <table cellpadding="20" cellspacing="20" width="20" border="0">
    <tr>
        <td>
            <video id="videoInput" style="display: none;" width=300 height=300></video>
        </td>
        <td>
          <canvas id="Hue_Filter" width=300 height=300</canvas>
        </td>
        <td>
          <canvas id="Saturation_Filter" width=300 height=300</canvas>
        </td>
    </tr>
    <tr>
        <td>
          <canvas id="Value_Filter" width=300 height=300</canvas>
        </td>
        <td>
          <canvas id="Combined_Filter" width=300 height=300</canvas>
        </td>
        <td>
            <canvas id="canvasOutput" width=300 height=300></canvas>
        </td>
    </tr>
    <tr>
        <td>
            <div class="caption" style="display: none;" >videoInput </div>
        </td>
        <td>
          <div class="caption">Hue_Filter</div>
        </td>
        <td>
          <div class="caption">Saturation_Filter</div>
        </td>
        <td>
          <div class="caption">Value_Filter</div>
        </td>
        <td>
          <div class="caption">Combined_Filter</div>
        </td>
        <td>
            <div class="caption">canvasOutput</div>
        </td>
        <td></td>
        <td></td>
    </tr>
    </table>
</div>
<script src="https://webrtc.github.io/adapter/adapter-5.0.4.js" type="text/javascript"></script>
<script src="utils.js" type="text/javascript"></script>
<script id="codeSnippet" type="text/code-snippet">
let video = document.getElementById('videoInput');
let src = new cv.Mat(video.height, video.width, cv.CV_8UC4);
let dst = new cv.Mat(video.height, video.width, cv.CV_8UC1);
let cap = new cv.VideoCapture(video);


const FPS = 5;
function processVideo() {
    try {
        if (!streaming) {
            // clean and stop.
            src.delete();
            dst.delete();
            return;
        }
        let begin = Date.now();
        // start processing.
        cap.read(src);
        cv.cvtColor(src, dst, cv.COLOR_RGB2HSV);
        let kernel = cv.getStructuringElement(cv.MORPH_RECT,new cv.Size(5,5))
        cv.erode(dst,dst,kernel)
        cv.medianBlur(dst,dst,5)
        cv.GaussianBlur(dst,dst,new cv.Size(7,7),5,5)
        let channels = new cv.MatVector()
        cv.split(dst,channels)

        let minHue = new cv.Mat(video.height, video.width, channels.get(0).type(),[12,12,12,12])
        let maxHue = new cv.Mat(video.height, video.width, channels.get(0).type(),[25,25,25,25])


        let minSat = new cv.Mat(channels.get(1).rows,channels.get(1).cols, channels.get(1).type(),[78,78,78,78])
        let maxSat = new cv.Mat(channels.get(1).rows,channels.get(1).cols, channels.get(1).type(),[255,255,255,255])
        let minVal = new cv.Mat(channels.get(2).rows,channels.get(2).cols, channels.get(2).type(),[189,189,189,189])
        let maxVal = new cv.Mat(channels.get(2).rows,channels.get(2).cols, channels.get(2).type(),[255,255,255,255])

        cv.inRange(channels.get(0),minHue,maxHue,channels.get(0))
        cv.inRange(channels.get(1),minSat,maxSat,channels.get(1))
        cv.inRange(channels.get(2),minVal,maxVal,channels.get(2))
        let hs = new cv.Mat()
        let combined = new cv.Mat()
        cv.bitwise_and(channels.get(0),channels.get(1),hs)
        cv.bitwise_and(channels.get(2),hs,combined)
        var contours = new cv.MatVector()
        let hierarchy = new cv.Mat()
        cv.findContours(combined, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);
        cv.imshow('Hue_Filter',channels.get(0))
        cv.imshow('Saturation_Filter',channels.get(1))
        cv.imshow('Value_Filter',channels.get(2))
        cv.imshow('Combined_Filter',combined)
        channels.get(0).delete()
        channels.get(1).delete()
        channels.get(2).delete()
        hs.delete()
        combined.delete()
         for (let i = 0; i < contours.size(); i++){
             let cnt = contours.get(i)
             let rotatedRect = cv.minAreaRect(cnt)
             let area = rotatedRect.size.width * rotatedRect.size.height
             console.log(cv)
             let vertices = cv.RotatedRect.points(rotatedRect)
             let contoursColor = new cv.Scalar(0,255,0,255)
             let rectangleColor = new cv.Scalar(0,255,0,255)
             //console.log(point.x)
             //cv.drawContours(src,contours,i,contoursColor,1,8,hierarchy,100)
             // draw rotatedRect
             if (area < 2200 && area > 600){
               for (let i = 0; i < 4; i++) {
                    cv.line(src, vertices[i], vertices[(i + 1) % 4], rectangleColor, 2, cv.LINE_AA, 0);
                }
                let point = rotatedRect.center
                console.log("Center X:" + String(point.x))
                console.log("Center Y:" + String(point.y))
                  //console.log(vertices[0].x)
              }
         }

        //cv.imshow('canvasOutput', dst);
        cv.imshow('canvasOutput',src)
        // schedule the next one.
        let delay = 1000/FPS - (Date.now() - begin);
        setTimeout(processVideo, delay);
    } catch (err) {
        utils.printError(err);
    }
};

setTimeout(processVideo, 0);
</script>
<script type="text/javascript">
let utils = new Utils('errorMessage');

utils.loadCode('codeSnippet', 'codeEditor');

let streaming = false;
let videoInput = document.getElementById('videoInput');
let startAndStop = document.getElementById('startAndStop');
let canvasOutput = document.getElementById('canvasOutput');
let canvasContext = canvasOutput.getContext('2d');

startAndStop.addEventListener('click', () => {
    if (!streaming) {
        utils.clearError();
        utils.startCamera('qvga', onVideoStarted, 'videoInput');
    } else {
        utils.stopCamera();
        onVideoStopped();
    }
});

function onVideoStarted() {
    streaming = true;
    startAndStop.innerText = 'Stop';
    videoInput.width = videoInput.videoWidth;
    videoInput.height = videoInput.videoHeight;
    utils.executeCode('codeEditor');
}

function onVideoStopped() {
    streaming = false;
    canvasContext.clearRect(0, 0, canvasOutput.width, canvasOutput.height);
    startAndStop.innerText = 'Start';
}

utils.loadOpenCv(() => {
    startAndStop.removeAttribute('disabled');
});
</script>
</body>
</html>
